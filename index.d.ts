/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Hash algorithms implemented by this crate.
 *
 * Implemented primarily based on the high-level descriptions on the blog Hacker Factor
 * written by Dr. Neal Krawetz: http://www.hackerfactor.com/
 *
 * Note that `hash_width` and `hash_height` in these docs refer to the parameters of
 * [`HasherConfig::hash_size()`](struct.HasherConfig.html#method.hash_size).
 *
 * ### Choosing an Algorithm
 * Each algorithm has different performance characteristics
 */
export const enum HashAlgorithm {
	/**
	 * The Mean hashing algorithm.
	 *
	 * The image is converted to grayscale, scaled down to `hash_width x hash_height`,
	 * the mean pixel value is taken, and then the hash bits are generated by comparing
	 * the pixels of the descaled image to the mean.
	 *
	 * This is the most basic hash algorithm supported, resistant only to changes in
	 * resolution, aspect ratio, and overall brightness.
	 *
	 * Further Reading:
	 * http://www.hackerfactor.com/blog/?/archives/432-Looks-Like-It.html
	 */
	Mean = 0,
	/**
	 * The Gradient hashing algorithm.
	 *
	 * The image is converted to grayscale, scaled down to `(hash_width + 1) x hash_height`,
	 * and then in row-major order the pixels are compared with each other, setting bits
	 * in the hash for each comparison. The extra pixel is needed to have `hash_width` comparisons
	 * per row.
	 *
	 * This hash algorithm is as fast or faster than Mean (because it only traverses the
	 * hash data once) and is more resistant to changes than Mean.
	 *
	 * Further Reading:
	 * http://www.hackerfactor.com/blog/index.php?/archives/529-Kind-of-Like-That.html
	 */
	Gradient = 1,
	/**
	 * The Vertical-Gradient hashing algorithm.
	 *
	 * Equivalent to [`Gradient`](#variant.Gradient) but operating on the columns of the image
	 * instead of the rows.
	 */
	VertGradient = 2,
	/**
	 * The Double-Gradient hashing algorithm.
	 *
	 * An advanced version of [`Gradient`](#variant.Gradient);
	 * resizes the grayscaled image to `(width / 2 + 1) x (height / 2 + 1)` and compares columns
	 * in addition to rows.
	 *
	 * This algorithm is slightly slower than `Gradient` (resizing the image dwarfs
	 * the hash time in most cases) but the extra comparison direction may improve results (though
	 * you might want to consider increasing
	 * [`hash_size`](struct.HasherConfig.html#method.hash_size)
	 * to accommodate the extra comparisons).
	 */
	DoubleGradient = 3,
	/**
	 * The [Blockhash.io](https://blockhash.io) algorithm.
	 *
	 * Compared to the other algorithms, this does not require any preprocessing steps and so
	 * may be significantly faster at the cost of some resilience.
	 *
	 * The algorithm is described in a high level here:
	 * https://github.com/commonsmachinery/blockhash-rfc/blob/master/main.md
	 */
	Blockhash = 4,
}
/**
 * get hash of an image
 *
 * # Arguments
 * * `input` - Either a Buffer or an image url
 * * `hash_algo` - Optional hash algorithm
 *
 * # Example
 * ```js
 * const { getHash } = require('img-hasher');
 * const hash = await getHash('https://example.com/image.jpg');
 * ```
 */
export function getHash(input: Buffer | string, hashAlgo?: HashAlgorithm | undefined | null): Promise<string>;
/**
 * get hamming distance of two image hashes
 *
 * # Arguments
 * * `input1` - Image hash
 * * `input2` - Image hash
 *
 * # Example
 * ```js
 * const { getHash, hammingDistanceFromHash } = require('img-hasher');
 * const hash1 = await getHash('https://example.com/image1.jpg');
 * const hash2 = await getHash('https://example.com/image2.jpg');
 * const distance = hammingDistanceFromHash(hash1, hash2);
 * ```
 */
export function hammingDistanceFromHash(input1: string, input2: string): number;
/**
 * get hamming distance of two images
 *
 * # Arguments
 * * `input1` - Either a Buffer or an image url
 * * `input2` - Either a Buffer or an image url
 * * `hash_algo` - Optional hash algorithm
 *
 * # Example
 * ```js
 * const { hammingDistance } = require('img-hasher');
 * const distance = await hammingDistance('https://example.com/image1.jpg', 'https://example.com/image2.jpg');
 * ```
 */
export function hammingDistance(
	input1: Buffer | string,
	input2: Buffer | string,
	hashAlgo?: HashAlgorithm | undefined | null,
): Promise<number>;
